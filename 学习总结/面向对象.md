> 对象：无序属性集合，其属性可以包含基本值、对象、函数。
## 创建对象
### 工厂模式
#### 具体实现
```
function createPerson(name, age, job) {
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    alert(this.name);
  };
  return o;
}
```
> 缺点：工厂模式解决了创建多个相似对象的问题，却没有解决对象的识别问题
- - - - - 
### 构造函数模式
#### 具体实现
```
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    alert(this.name);
  };
}
```
> 缺点：构造函数的主要问题，每个方法都要在每个实例上重新创建
#### 修改后
```
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = sayName;
}
function sayName() {
  alert(this.name);
}
```
> 缺点：如果对象需要定义很多方法，就要定义很多全局函数，那自定义的引用类型就没有封装性了
- - - - -
### 原型模式
#### prototype就是通过调用构造函数而创建那个对象实例的原型对象
```
function Person() {

}
Person.prototype.name = 'lisi';
Person.prototype.age = 23;
Person.prototype.job = 'Software Engineer';
Person.prototype.sayName = function() {
  alert(this.name);
};
```
> 缺点：通过对象实例访问保存在原型中的值，却不能通过对象实例重写原型中的值
- - - - -
### 组合使用构造函数模式和原型模式
#### 构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性
```
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
}
Person.prototype = {
  constructor: Person,
  sayName: function() {
    alert(this.name);
  }
}
```
> 这是定义引用类型的一种默认模式
- - - - -
### 动态原型模式
#### 将所有信息都封装在构造函数，必要情况下在构造函数中初始化原型
```
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  if(typeof(this.sayName) != 'function') {
    Person.prototype.sayName = function() {
      alert(this.name);
    };
  }
}
```
- - - - -
### 寄生构造函数模式
#### 与工厂模式相同，只是使用了new操作符
```
function Person(name, age, job) {
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    alert(this.name);
  }
  return o;
}
```
> 寄生构造函数返回的对象与构造函数或者构造函数的原型属性之间没有关系
- - - - - 
### 稳妥构造函数模式
#### 与寄生构造函数模式相同，但不引用this和new操作符调用构造函数
```
function Person(name, age, job) {
  var o = new Object();
  o.sayName = function() {
    alert(name);
  };
  return o; 
}
```
> 除了sayName() 方法外，没有别的方式访问其数据成员
- - - - - 
## 继承
### 原型链
#### 利用原型让一个引用类型继承另一个引用类型的属性和方法
## 标签语义化的理解
1. 在没有CSS时，页面也能呈现很好的内容结构、代码结构。
2. 有利于SEO： 与搜索引擎建立良好的沟通，有利于爬虫抓取有效信息。
3. 方便其他设备解析，以有意义的方式渲染页面。
4. 方便团队的开发与维护。
- - - - -
## Doctype
1. Doctype的作用：告诉浏览器以何种模式渲染页面
2. Doctype的文档类型：struct(严格版本)、transitional(过渡版本)、frameset(基于框架的HTML文档)
3. 严格模式：排版和js运作模式是以浏览器支持的最高标准运行
4. 混杂模式：页面以宽松的向后兼容的方式呈现
> Doctype 不存在或格式不正确会使文档以混杂模式呈现
- - - - -
## HTML 于 XHTML
#### 区别：
1. XHTML 文档必须有根元素
2. XHTML 标签名必须用小写字母
3. XHTML 元素必须正确嵌套
4. XHTML 元素必须被关闭
- - - - -
## 浮动
1. 原理：使元素脱离文档流，不占据空间
2. 引发的问题：1、父元素的高度无法撑开，影响与父元素同级的元素。2、与浮动元素同级的非浮动元素也会紧跟其后。3、若浮动元素不是第一个元素，那浮动元素之前的元素也要浮动，不然会影响页面结构。
3. 清除浮动的技巧：1、在浮动标签后添加空标签 clear: both; 2、设置父元素 overflow: hidden; 3、使用:after {content: "", display: block, clear: both}
- - - - - 
## 性能优化
1. 减少http的请求。CSS sprites，压缩js、CSS源码，图片大小控制合适，网页gzip，cdn托管，data缓存，图片服务器。
2. 减少由于HTML标签导致的带宽浪费，前端用变量保存Ajax请求结果，操作本地变量不用请求，减少请求次数。
3. 用innerHTML 代替DOM 操作，减少DOM操作，优化JavaScript性能。
4. 需要设置的样式很多时使用ClassName的方式，少操作style
5. 少用全局变量，缓存DOM节点查找的结果。减少I/O 读取操作
- - - - - 
## Web Storage 和 Cookie 相比的优势
1. 存储空间更大
2. 存储内容不会发送到服务器，Web Storage 会存储在本地，不会与服务器发生交互。Cookie 的内容会随着请求发送给服务器
3. 更丰富易用的接口
4. 独立的存储空间
- - - - - 
## Ajax 编程步骤
1. 创建 XMLHttpRequest 对象
`var xhr = new XMLHttpRequest();`
2. 设置请求方式
```
xhr.open('post', url, true);
```
3. 调用回调函数
```
xhr.onreadystatechange = function() {
  if(xhr.status === 200 && xhr.readyState == 4) {
    var id = document.getElementById("id");
    id.innerHTML = xhr.responseText;
  } else {
    alert("AJAX 服务器返回错误！");
  }
};
```
4. 发送请求
```
xhr.setRequestHeader("Content-type", "appication/x-www-form-urlencoded;charset=UTF-8");
xhr.send(data);
```
- - - - -
## 常用HTTP状态码
1. 200 状态：请求已成功，请求所希望的响应头或数据体将随此响应返回
2. 201 状态：请求成功且服务器创建了新资源，且其 URL 已经随 Location 头信息返回
3. 202 状态：服务器已接收请求但尚未处理
4. 301 状态：被请求的资源已永久移动到新位置
5. 302 状态：请求资源临时从不同的 URL 响应请求，但请求者仍然用原来的位置来进行以后的请求
6. 304 状态：上次请求后，请求的网页没有修改过
7. 401 状态：请求要求身份验证
8. 402 状态：服务器已经理解请求，但拒绝执行它
9. 404 状态：请求失败，请求的资源未在服务器上发现
10. 500 状态：服务器遇到未曾预计的状况，导致它无法完成对请求的处理
11. 503 状态：由于临时的服务器维护或过载，服务器当前无法处理请求
- - - - - 
## 跨域问题
### 跨域：js在不同域之间进行数据传输或通信。同域：是指协议、域名、端口号全相同
### 限制：这个源的文档没有资格去操作另一个源的文档。
#### 具体体现在：1）cookie、localstorage、indexDB 无法获取。2）无法获取和操作DOM。3）不能发送ajax请求，ajax只适合同源通信 
### 解决方法
1. 通过jsonp跨域：动态使用 `<script>` 标签，设置一个跨域的 URL，使用回调函数处理 JSON 数据  
```
var url = 'http://localhost:8080/testjson.do?jsonp=callbackfun';
var script = document.createElement('script');
script.setAttribute('src', url);
var head = document.getElementByTagName('head')[0];
head.appendChild(script);
function callback(data) {
  var html = JSON.stringify(data.RESULTSET);
}
```
> 优点：简单易用，兼容性好，支持浏览器和服务器双向通信。缺点：只支持 get 请求
2. CORS - Cross-origin resource sharing（跨资源共享）
> 它允许浏览器向跨源服务器，发送 XMLHTTPRequest 请求，克服 AJAX 只能同源使用的限制
> 通过设置 Access-Control-Allow-Origin 来允许跨域，兼容性没有 jsonp 好
3. window.name + iframe
```
<iframe src=跨域名 frameborder='1'></iframe>
<script>
var iframe = document.querySelector("iframe");
iframe.style.display = 'none';
var flag = 0;
iframe.onload = function() {
  if(flag == 1) {
    alert('获取跨域数据：', iframe.contentWindow.name);
    iframe.contentWindow.close();
  } else {
    flag = 1;
    iframe.contentWindow.location = 当前域;
  }
}
</script>
```
> 即在一个窗口的生命周期内，载入的所有窗口都共享一个 window.name，不论 iframe 的 URL 怎么变化，window.name 都不变
4. html5 提供的 window.postMessage
- - - - - 
## 同步、异步、延迟加载
1. 同步加载 - 阻塞模式：会阻止浏览器的后续处理，停止了后续的解析，因此停止了对后续文件加载、渲染、代码执行
2. 异步加载 - 非阻塞模式：浏览器在下载执行 js 时，还会继续后续网页的处理
3. 延迟加载：一开始并不加载暂时不用的 js ，在后续需要时再通过 js 的控制实现异步加载 
- - - - -
## 函数防抖、函数节流
#### 函数防抖 - 一个事件被频繁触发时，会清除掉上一次的时间延迟，开始新一轮的延迟，意味着只执行最后一次触发
```
var timer = false;
window.onscroll = function() {
  clearTimeout(timer);
  timer = setTimeout(function() {

  }, 500);
};
```
> 应用场景：用于注册时验证手机号、邮箱，用户输入完后检查格式
#### 函数节流 - 一个事件被频繁触发，会先判断事件是否正在执行，如果正在执行直接return，意味着只有本次触发完成后才会执行下一次触发
```
var canrun = true;
window.onscroll = function() {
  if(!canrun) {
    return;
  }
  canrun = false;
  timer = setTimeout(function() {
    canrun = true;
  }, 500);
};
```
> 应用场景：监听页面的滚动事件